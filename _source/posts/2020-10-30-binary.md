---
title: Binary ùë£ùë† Text
date: 2020-10-30
tags: concept education-and-culture
image: //img.cacilhas.cc/glider.png
permalink: /2020/10/binary.html
---
[image]: {{{image}}}
[Diferen√ßa entre dado bin√°rio e dado textual]: https://kodumaro.pages.dev/2017/06/binario-texto.html
[DEV.to]: https://dev.to/cacilhas/binary-vs-text-2blo
[SDXF]: http://www.pinpi.com/en/SDXF_2.htm

:right ![MoonScript][image]

:first I‚Äôve seen people not understanding the difference between binary and
text.

In this context, binary and text are ways the data is represented.

### Binary protocol

The binary protocol uses bytes to represent data as directly as possible.

Let‚Äôs take the number 98&#8239;765. Converting from decimal to binary one gets:

:centre 1.1000.0001.1100.1101‚ÇÇ

C has a type named `int` that represents integers as 4-byte data. Regrouping the
data above in 8-bit chunks (bytes), and completing the 4 bytes with zeros:

:centre 00000000.00000001.10000001.11001101‚ÇÇ

Counter-intuitively, the simplier way to represent binary data isn‚Äôt binary,
but hexadecimal. Each 4 bits turns directly into a hexadecimal digit, so every
byte is represented as 2 hexadecimal digits. So we got:

:centre 00.01.81.CD‚ÇÅ‚ÇÜ

The mathematical representation of numbers is **big-endian**, which means, the
more representative digit comes first. Network uses big-endian too.

Most of the operating systems are **little-endian**, which means, the inverted
order from big-endian:

:centre CD.81.01.00‚ÇÅ‚ÇÜ

Considering we‚Äôre building a binary protocol. It needs to supply the data type
in order to identify which kind of data we‚Äôre talking about.

For simplicity (something like [SDXF][]), let‚Äôs use 1-byte type tag. For
informing integer, let‚Äôs use the number 2:

:centre 02.00.01.81.CD‚ÇÅ‚ÇÜ

### Text protocol

Text data are fully represented as strings. So the number 98&#8239;765 is
represented as the characters needed to write the decimal number:

:centre 39.38.37.36.35‚ÇÅ‚ÇÜ

Now it needs a way to tell the system where the string ends. C uses the null
character as stop one:

:centre 39.38.37.36.35.00‚ÇÅ‚ÇÜ

Pascal starts the string with 2 bytes telling the string length:

:centre 05.00.39.38.37.36.35‚ÇÅ‚ÇÜ

But, in text protocols, we cannot use non-text bytes (like 05‚ÇÅ‚ÇÜ), so we need to
represent it as text too, using a separator (CR, for example) to distinguish the
length from the data:

:centre 35.0C.39.38.37.36.35‚ÇÅ‚ÇÜ

Let‚Äôs put it all in perspective:

|      | Locally             | Network                |
|------|:-------------------:|:----------------------:|
|Binary|    CD.81.01.00‚ÇÅ‚ÇÜ    |    02.00.01.81.CD‚ÇÅ‚ÇÜ    |
|Text  | 39.38.37.36.35.00‚ÇÅ‚ÇÜ | 35.0C.39.38.37.36.35‚ÇÅ‚ÇÜ |

### Strings

And what about strings? Over a binary protocol, strings are easily represented,
one just needs a type flag, the string length, and the string itself.

Let‚Äôs take `Kodumaro` (4B.6F.64.75.6D.61.72.6F‚ÇÅ‚ÇÜ):

:centre 01.4B.6F.64.75.6D.61.72.6F.00‚ÇÅ‚ÇÜ

Or, in a network transmission:

:centre 01.08.00.4B.6F.64.75.6D.61.72.6F‚ÇÅ‚ÇÜ

Over a text protocol, it usually uses a terminator character on both ends. The
most common is the quotation mark (`"`, 22‚ÇÅ‚ÇÜ):

:centre 31.30.0C.22.4B.6F.64.75.6D.61.72.6F.22‚ÇÅ‚ÇÜ

|      | Locally                          | Network                                |
|------|:--------------------------------:|:--------------------------------------:|
|Binary|  4B.6F.64.75.6D.61.72.6F.00‚ÇÅ‚ÇÜ    |   01.08.00.4B.6F.64.75.6D.61.72.6F‚ÇÅ‚ÇÜ   |
|Text  |22.4B.6F.64.75.6D.61.72.6F.22.00‚ÇÅ‚ÇÜ|31.30.0C.22.4B.6F.64.75.6D.61.72.6F.22‚ÇÅ‚ÇÜ|

### Afterword

I hope you can see how text representations are heavier than binary ones. Things
get worse when considering the protocol headers.

Everytime it‚Äôs possible, prefer binary representations over text.

-----

Original post (in Portuguese):
[Diferen√ßa entre dado bin√°rio e dado textual][].

:small Also in [DEV.to][].
